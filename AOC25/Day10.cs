// 2025/12/10 18:00
// 2025/12/12 21:38
// https://adventofcode.com/2025/day/10

using System.Data;
using System.Diagnostics;
using MathNet.Numerics.LinearAlgebra;
using MathNet.Numerics.LinearAlgebra.Double;
using Google.OrTools.Sat;

public class Machine {
  public List<bool> Config = new();
  public List<List<int>> Buttons = new();
  public List<int> Joltage = new();
  public uint ConfigNumber = 0;
  public List<uint> ButtonsAsNumbers = new();

  public static uint ConfigToUInt(List<bool> config) {
    uint result = 0;
    for (int i = config.Count - 1; i >= 0; i--) {
      if (config[i]) {
        result |= (uint)1 << i;
      }
    }
    return result;
  }

  public static uint ButtonsToUInt(List<int> buttons) {
    uint result = 0;
    for (int i = 0; i < buttons.Count; i++) {
      result |= (uint)1 << buttons[i];
    }
    return result;
  }

  public Machine(string line) {
    // [.##.] (3) (1,3) (2) (2,3) (0,2) (0,1) {3,5,4,7}
    var parts = line.Split(" ");

    foreach (var part in parts) {
      if (part.StartsWith("[") && part.EndsWith("]")) {
        // Parse Config
        for (int i = 1; i < part.Length - 1; i++) {
          if (part[i] == '#') {
            Config.Add(true);
          } else {
            Config.Add(false);
          }
        }
      } else if (part.StartsWith("(") && part.EndsWith(")")) {
        // Parse buttons
        var nums = part
          .Substring(1, part.Length - 2)
          .Split(',')
          .Select(s => int.Parse(s))
          .ToList();
        Buttons.Add(nums);
      } else if (part.StartsWith("{") && part.EndsWith("}")) {
        // Parse joltage
        var nums = part
          .Substring(1, part.Length - 2)
          .Split(',')
          .Select(s => int.Parse(s))
          .ToList();
        Joltage = nums;
      }
    }

    ConfigNumber = ConfigToUInt(Config);
    ButtonsAsNumbers = Buttons.Select(b => ButtonsToUInt(b)).ToList();
  }
}


public class Day10 {

  // Solution generated by GPT
  static int SolveMachineWithOrTools(Machine m) {
    int nButtons = m.ButtonsAsNumbers.Count;
    int nCounters = m.Joltage.Count;

    var model = new CpModel();

    // x_j = number of presses of button j (non-negative integer)
    var x = new IntVar[nButtons];
    for (int j = 0; j < nButtons; j++)
      x[j] = model.NewIntVar(0, 1_000_000, $"x{j}");

    // Counter constraints: sum of buttons affecting counter i == joltage[i]
    for (int i = 0; i < nCounters; i++) {
      var terms = new List<LinearExpr>();
      for (int j = 0; j < nButtons; j++) {
        if (((m.ButtonsAsNumbers[j] >> i) & 1u) != 0)
          terms.Add(x[j]);
      }
      model.Add(LinearExpr.Sum(terms) == m.Joltage[i]);
    }

    // Objective: minimize total presses
    model.Minimize(LinearExpr.Sum(x));

    var solver = new CpSolver();
    solver.StringParameters = "num_search_workers: 8";

    var status = solver.Solve(model);
    if (status != CpSolverStatus.Optimal)
      throw new InvalidOperationException("No solution");

    int sum = 0;
    for (int j = 0; j < nButtons; j++)
      sum += (int)solver.Value(x[j]);

    return sum;
  }


  List<Machine> Machines = [];
  private void _ReadInput() {
    string filepath = "data/input1.txt";
    string[] lines = File.ReadAllLines(filepath);
    foreach (string line in lines) {
      Machines.Add(new Machine(line));
    }
  }

  public bool IsInteger(double value) {
    return Math.Abs(value - Math.Round(value)) < 1e-9;
  }

  public IEnumerable<List<int>> GenerateCombinations(int index, int count) {
    if (index == count) {
      yield return [index];
      yield return [];
    } else {
      foreach (var chosen in GenerateCombinations(index + 1, count)) {
        yield return chosen;

        chosen.Add(index);
        yield return chosen;
        chosen.Remove(index);
      }
    }
  }

  public void PrintList(List<int> ls) {
    Console.Write("[");
    foreach (var c in ls) {
      Console.Write(c);
      Console.Write(",");
    }
    Console.WriteLine("]");
  }

  public int GetButtonPresses(Machine machine) {
    int minButtons = int.MaxValue;
    foreach (var combo in GenerateCombinations(0, machine.Buttons.Count - 1)) {
      uint result = machine.ConfigNumber;
      foreach (var bi in combo) {
        result ^= machine.ButtonsAsNumbers[bi];
      }

      if (result == 0) {
        minButtons = Math.Min(minButtons, combo.Count);
      }
    }
    return minButtons;
  }

  public void Solve1() {
    int answer = 0;
    foreach (var machine in Machines) {
      answer += GetButtonPresses(machine);
    }
    Console.WriteLine(answer);
  }

  public int Joltage(Machine machine, int currentIndex, List<int> joltageState, int presses) {
    if (currentIndex >= machine.Buttons.Count) {
      if (joltageState.Sum() == 0) {
        return presses;
      } else {
        return int.MaxValue;
      }
    }

    int numMultiples = joltageState
      .Where((j, ji) => machine.Buttons[currentIndex].Contains(ji))
      .Min();

    int answer = int.MaxValue;
    for (int mult = 0; mult <= numMultiples; mult++) {

      // Compute the next joltage state by pressing the buttons
      var nextJoltageState = new List<int>(joltageState);
      foreach (var ji in machine.Buttons[currentIndex]) {
        nextJoltageState[ji] -= mult;
      }
      Debug.Assert(nextJoltageState.All(j => j >= 0));

      var cand = Joltage(machine, currentIndex + 1, nextJoltageState, presses + mult);
      answer = Math.Min(cand, answer);
    }

    return answer;
  }

  public int Hash(List<int> joltageState) {
    var hash = new HashCode();
    foreach (var item in joltageState) {
      hash.Add(item);
    }
    return hash.ToHashCode();
  }

  public List<int> MinIndex(List<int> ls) {
    int minIndex = -1;
    for (int i = 0; i < ls.Count; i++) {
      if (ls[i] == 0) { continue; }
      if (minIndex == -1 || ls[i] < ls[minIndex]) {
        minIndex = i;
      }
    }
    if (minIndex == -1) {
      return [];
    }

    List<int> minIndices = [];
    for (int index = 0; index < ls.Count; index++) {
      if (ls[index] == ls[minIndex]) {
        minIndices.Add(index);
      }
    }
    return minIndices;
  }

  public void ApplyButton(List<int> state, List<int> button, int incr = -1) {
    foreach (var toggleIndex in button) {
      state[toggleIndex] += incr;
    }
  }

  public IEnumerable<List<int>> GetCands(int total, List<int> spaces) {
    int spaceSum = spaces.Sum();
    if (spaces.Count == 1) {
      int limit = Math.Min(total, spaces[0]);
      yield return [limit];
    } else {
      int limit = Math.Min(total, spaces[0]);
      int nextSum = spaceSum - spaces[0];
      for (int amount = 0; amount <= limit; amount++) {
        int nextTotal = total - amount;
        if (nextSum < nextTotal) { continue; }

        foreach (var cand in GetCands(total - amount, spaces[1..])) {
          yield return new[] { amount }.Concat(cand).ToList();
        }
      }
    }
  }

  public List<(int, int)> GetAvailableButtons(Machine machine, List<int> state, int toggleIndex) {
    List<(int, int)> availableButtons = [];
    for (int buttonIndex = 0; buttonIndex < machine.Buttons.Count; buttonIndex++) {

      bool skipBecauseZero = false;
      bool containsToggleIndex = false;
      int minToggleValue = int.MaxValue;
      foreach (var ti in machine.Buttons[buttonIndex]) {
        if (ti == toggleIndex) {
          containsToggleIndex = true;
        }
        if (state[ti] == 0) {
          skipBecauseZero = true;
          break;
        }
        minToggleValue = Math.Min(minToggleValue, state[ti]);
      }
      if (skipBecauseZero) {
        continue;
      }

      if (containsToggleIndex) {
        availableButtons.Add((buttonIndex, minToggleValue));
      }
    }
    return availableButtons;
  }

  public List<int> GetButtonLimitsFromState(Machine machine, List<int> buttons, List<int> state) {
    List<int> limits = [];
    foreach (int buttonIndex in buttons) {

      int minValue = int.MaxValue;
      foreach (var toggleIndex in machine.Buttons[buttonIndex]) {
        if (state[toggleIndex] > 0) {
          minValue = Math.Min(state[toggleIndex], minValue);
        }
      }

      limits.Add(minValue);
    }

    return limits;
  }

  public int _GetJoltageButtonPresses(
    Machine machine,
    List<int> state,
    int presses
  ) {
    if (state.Sum() == 0) {
      return presses;
    }

    List<int> minToggleIndices = MinIndex(state);
    if (minToggleIndices.Count == 0) {
      return int.MaxValue;
    }

    int minPresses = int.MaxValue - 1;
    foreach (int toggleIndex in minToggleIndices) {
      int toggleCount = state[toggleIndex];

      // get available buttons
      var availableButtons = GetAvailableButtons(machine, state, toggleIndex);
      var buttonLimits = availableButtons.Select(a => a.Item2).ToList();

      if (availableButtons.Count == 0) {
        continue;
      }

      // for each button set
      foreach (List<int> cand in GetCands(toggleCount, buttonLimits)) {

        List<int> nextState = new(state);
        for (int index = 0; index < availableButtons.Count; index++) {
          var (buttonIndex, _) = availableButtons[index];
          ApplyButton(nextState, machine.Buttons[buttonIndex], -cand[index]);
        }

        var candidatePresses = _GetJoltageButtonPresses(machine, nextState, presses + cand.Sum());
        minPresses = Math.Min(minPresses, candidatePresses);
      }
    }

    return minPresses;
  }

  public IEnumerable<List<int>> GetSubsets(List<int> values) {
    int n = values.Count;
    int subsetCount = 1 << n;
    for (int i = 0; i < subsetCount; i++) {
      List<int> subset = [];
      for (int j = 0; j < n; j++) {
        if ((i & (1 << j)) != 0) {
          subset.Add(values[j]);
        }
      }
      yield return subset;
    }
  }

  public bool CheckCoverageOfSubset(Machine machine, List<int> subset) {
    HashSet<int> coveredIndices = new();
    foreach (var buttonIndex in subset) {
      foreach (var toggleIndex in machine.Buttons[buttonIndex]) {
        coveredIndices.Add(toggleIndex);
      }
    }
    return coveredIndices.Count == machine.Joltage.Count;
  }

  public bool canSolveWithSubset(Machine machine, List<int> subset, int numPresses) {


    // Try every candidate distribution of presses across the buttons
    return false;
  }

  public (Matrix<double>, Vector<double> y, int) SolveSystemOfEquations(Matrix<double> A, Vector<double> y) {
    // For underdetermined system with integer constraint:
    // Try all non-negative integer combinations up to reasonable bounds
    int numRows = A.RowCount;
    int numCols = A.ColumnCount;
    Debug.Assert(A.RowCount == y.Count);


    void SwapRows(int i, int j) {
      for (int col = 0; col < numCols; col++) {
        double temp = A[i, col];
        A[i, col] = A[j, col];
        A[j, col] = temp;
      }
      double tempY = y[i];
      y[i] = y[j];
      y[j] = tempY;
    }

    void MultRow(int i, double factor) {
      for (int col = 0; col < numCols; col++) {
        A[i, col] *= factor;
      }
      y[i] *= factor;
    }

    void AddRowMult(int sourceRow, int targetRow, double factor) {
      for (int col = 0; col < numCols; col++) {
        A[targetRow, col] += A[sourceRow, col] * factor;
      }
      y[targetRow] += y[sourceRow] * factor;
    }

    bool ColIsZero(int col) {
      for (int row = 0; row < numRows; row++) {
        if (A[row, col] != 0) {
          return false;
        }
      }
      return true;
    }

    int FindNonZeroRowBelow(int row, int col) {
      int candidateRow = -1;
      for (int r = row + 1; r < numRows; r++) {
        if (A[r, col] == 1.0) {
          // Prefer a row with a leading 1
          return r;
        } else if (A[r, col] == -1.0) {
          // Prefer a row with a leading -1
          return r;
        } else if (A[r, col] != 0) {
          candidateRow = r;
        }
      }
      return candidateRow;
    }

    bool CheckZerosBelow(int row, int col) {
      for (int r = row + 1; r < numRows; r++) {
        if (A[r, col] != 0) {
          return false;
        }
      }
      return true;
    }

    int FindRowBelowWithLeadingOne(int row, int col) {
      for (int r = row + 1; r < numRows; r++) {
        if (A[r, col] == 1.0 || A[r, col] == -1.0) {
          return r;
        }
      }
      return -1;
    }

    void ConvertToRowEchelonForm() {
      int pivot = -1;
      for (int col = 0; col < numCols; col++) {
        Debug.Assert(!ColIsZero(col));

        if (CheckZerosBelow(pivot, col)) {
          // This column is already done, keep going
          continue;
        }
        pivot += 1;

        // Swap the pivot row into position
        if (A[pivot, col] == 0) {
          int nonZeroRow = FindNonZeroRowBelow(pivot, col);
          Debug.Assert(nonZeroRow != -1);
          SwapRows(pivot, nonZeroRow);
        }

        // Make the leading cell a 1.0
        // If a row with a leading Abs(1.0) exists, swap it instead of dividing
        int candSwitch = FindRowBelowWithLeadingOne(pivot, col);
        if (candSwitch != -1) {
          SwapRows(pivot, candSwitch);
        }
        MultRow(pivot, 1.0 / A[pivot, col]);

        // Make all the rows below the leading cell zeroes
        for (int r = pivot + 1; r < numRows; r++) {
          AddRowMult(pivot, r, -A[r, col]);
        }
      }
    }

    int findPivotColumnInRow(int r) {
      // Find the pivot column
      int pivot = -1;
      for (int c = 0; c < numCols; c++) {
        if (A[r, c] == 1.0) {
          pivot = c;
          break;
        }
      }
      return pivot;
    }

    void ConvertToReducedRowEchelonForm() {
      for (int r = 0; r < numRows; r++) {

        int pivot = findPivotColumnInRow(r);
        if (pivot == -1) { continue; }

        // Eliminate all rows above
        for (int upperRow = 0; upperRow < r; upperRow++) {
          AddRowMult(r, upperRow, -A[upperRow, pivot]);
        }
      }
    }

    int CountNumberFreeVariables() {
      int numPivots = 0;
      for (int r = 0; r < numRows; r++) {
        int pivot = findPivotColumnInRow(r);
        if (pivot != -1) {
          numPivots += 1;
        }
      }
      return numCols - numPivots;
    }

    // Console.WriteLine("Original Matrix A:");
    // Console.WriteLine(A.ToString());
    // Console.WriteLine(y.ToString());
    ConvertToRowEchelonForm();
    // Console.WriteLine("REF Matrix A:");
    // Console.WriteLine(A.ToString());
    // Console.WriteLine(y.ToString());
    ConvertToReducedRowEchelonForm();
    // Console.WriteLine("RREF Matrix A:");
    // Console.WriteLine(A.ToString());
    // Console.WriteLine(y.ToString());
    int freeVars = CountNumberFreeVariables();
    // Console.WriteLine($"Number of free variables: {CountNumberFreeVariables()}");
    // if (freeVars == 0) {
    //   Console.WriteLine(A.ToString());
    //   Console.WriteLine(y.ToString());
    // }

    return (A, y, freeVars);
  }

  public Vector<double> BackSubstituteMatrix(Matrix<double> A, Vector<double> y) {
    int numRows = A.RowCount;
    int numCols = A.ColumnCount;
    Debug.Assert(A.RowCount == y.Count);

    double[] solution = new double[numCols];
    for (int r = numRows - 1; r >= 0; r--) {
      // Find the pivot column
      int pivotCol = -1;
      for (int c = 0; c < numCols; c++) {
        if (A[r, c] == 1.0) {
          pivotCol = c;
          break;
        }
      }
      if (pivotCol == -1) {
        // All-zero row
        continue;
      }

      // solution[pivotCol] = (int)Math.Round(y[r]);
      solution[pivotCol] = y[r];
    }

    return DenseVector.OfArray(solution);
  }

  public int HandleFreeVars(
    Machine machine,
    Matrix<double> A,
    Vector<double> y
  ) {
    // Need to try all combinations of free variables up to reasonable bounds
    int numRows = A.RowCount;
    int numCols = A.ColumnCount;
    Debug.Assert(A.RowCount == y.Count);


    int GetPivotInRow(int r) {
      for (int c = 0; c < numCols; c++) {
        if (A[r, c] != 0.0) {
          return c;
        }
      }
      return -1;
    }

    List<(int, int)> pivots = [];
    for (int r = 0; r < numRows; r++) {
      int pivot = GetPivotInRow(r);
      if (pivot == -1) { continue; }
      pivots.Add((r, pivot));
    }

    List<int> freeVariableCols = [];
    for (int col = 0; col < numCols; col++) {
      if (pivots.Any(p => p.Item2 == col)) {
        // this is a pivot column, so just ignore
        continue;
      }
      for (int r = 0; r < numRows; r++) {
        if (A[r, col] != 0.0) {
          freeVariableCols.Add(col);
          break;
        }
      }
    }

    List<int> freeVarLimits = [];
    foreach (var buttonIndex in freeVariableCols) {
      var button = machine.Buttons[buttonIndex];
      int minValue = int.MaxValue;
      foreach (var toggleIndex in button) {
        minValue = Math.Min(minValue, machine.Joltage[toggleIndex]);
      }
      freeVarLimits.Add(minValue);
    }


    // Make a copy of A and y which we can modify
    var A_copy = A.Clone();
    foreach (var freeCol in freeVariableCols) {
      // Zero out the free variable columns in A_copy
      for (int r = 0; r < numRows; r++) {
        A_copy[r, freeCol] = 0.0;
      }
    }

    IEnumerable<List<int>> GetCands(int index, List<int> limits) {
      if (index == limits.Count) {
        yield return [];
      } else {
        for (int value = 0; value <= limits[index]; value++) {
          foreach (var cand in GetCands(index + 1, limits)) {
            var newCand = new List<int>(cand);
            newCand.Insert(0, value);
            yield return newCand;
          }
        }
      }
    }

    bool CheckXSolution(Machine machine, Vector<double> x) {
      Debug.Assert(x.Count == machine.Buttons.Count);
      // Double check the solution of X makes the Joltage state
      List<int> state = new(machine.Joltage);
      for (int buttonIndex = 0; buttonIndex < machine.Buttons.Count; buttonIndex++) {
        // Check that the x[buttonIndex] is an integer
        if (!IsInteger(x[buttonIndex])) {
          return false;
        }

        // Apply the button presses
        int presses = (int)Math.Round(x[buttonIndex]);

        // Can't press a button a negative number of times
        if (presses < 0) {
          return false;
        }
        ApplyButton(state, machine.Buttons[buttonIndex], -presses);
      }
      return state.Sum() == 0;
    }

    // Console.Write(A.ToString());
    // Console.Write(y.ToString());
    // Console.WriteLine($"Pivots: {string.Join(", ", pivots.Select(p => p.ToString()))}");
    // Console.WriteLine($"Free variable columns: {string.Join(", ", freeVariableCols)}");
    // Console.WriteLine($"Free variable limits: {string.Join(", ", freeVarLimits)}");
    // Console.WriteLine($"Number of free variable combinations to try: {freeVarLimits.Aggregate(1, (a, b) => a * (b + 1))}");
    // Console.WriteLine($"Joltage state: {string.Join(", ", machine.Joltage)}");

    int minPresses = int.MaxValue - 1;
    foreach (var cand in GetCands(0, freeVarLimits)) {
      var y_copy = y.Clone();

      // Subtract the free variable contributions from y_copy
      for (int index = 0; index < freeVariableCols.Count; index++) {
        int freeCol = freeVariableCols[index];
        int freeValue = cand[index];

        for (int r = 0; r < numRows; r++) {
          y_copy[r] -= A[r, freeCol] * freeValue;
        }
      }

      var x = BackSubstituteMatrix(A_copy, y_copy);
      for (int index = 0; index < freeVariableCols.Count; index++) {
        int freeCol = freeVariableCols[index];
        int freeValue = cand[index];
        x[freeCol] = freeValue;
      }
      var x_cand = x.ToList().Sum();
      if (IsInteger(x_cand) && x_cand <= minPresses) {
        if (CheckXSolution(machine, x)) {
          minPresses = Math.Min(minPresses, (int)Math.Round(x_cand));
        }
      }
    }

    if (minPresses == int.MaxValue - 1) {
      Console.Write(A.ToString());
      Console.Write(y.ToString());
      Console.WriteLine($"Pivots: {string.Join(", ", pivots.Select(p => p.ToString()))}");
      Console.WriteLine($"Free variable columns: {string.Join(", ", freeVariableCols)}");
      Console.WriteLine($"Free variable limits: {string.Join(", ", freeVarLimits)}");
      Console.WriteLine($"Number of free variable combinations to try: {freeVarLimits.Aggregate(1, (a, b) => a * (b + 1))}");
      Console.WriteLine($"Joltage state: {string.Join(", ", machine.Joltage)}");
    }


    return minPresses;
  }


  public int _GetJoltageButtonPresses2(Machine machine) {
    double[,] _A = new double[machine.Joltage.Count, machine.Buttons.Count];
    for (int buttonIndex = 0; buttonIndex < machine.Buttons.Count; buttonIndex++) {
      foreach (var toggleIndex in machine.Buttons[buttonIndex]) {
        _A[toggleIndex, buttonIndex] = 1.0;
      }
    }
    double[] _y = new double[machine.Joltage.Count];
    for (int ji = 0; ji < machine.Joltage.Count; ji++) {
      _y[ji] = machine.Joltage[ji];
    }

    var A = DenseMatrix.OfArray(_A);
    var y = DenseVector.OfArray(_y);
    var (A1, y1, freeVars) = SolveSystemOfEquations(A, y);
    if (freeVars == 0) {
      var x = BackSubstituteMatrix(A1, y1);

      // Double check the solution of X makes the Joltage state
      List<int> state = new(machine.Joltage);
      for (int buttonIndex = 0; buttonIndex < machine.Buttons.Count; buttonIndex++) {
        int presses = (int)Math.Round(x[buttonIndex]);
        ApplyButton(state, machine.Buttons[buttonIndex], -presses);
      }
      Debug.Assert(state.Sum() == 0);

      var result = x.ToList().Sum();
      return (int)result;
    } else {
      int result = HandleFreeVars(machine, A1, y1);
      return result;
    }
  }

  public int GetJoltageButtonPresses(Machine machine) {
    return _GetJoltageButtonPresses2(machine);
    // return _GetJoltageButtonPresses(machine, machine.Joltage, 0);
  }

  public void Test1() {
    var rng = new Random();
    for (int spaceLimit = 1; spaceLimit < 10; spaceLimit++) {

      List<int> spaces = [];
      for (int j = 0; j < spaceLimit; j++) {
        spaces.Add(rng.Next() % 10);
      }
      int total = spaces.Sum();

      for (int j = 0; j < spaceLimit; j++) {
        spaces[j] += (rng.Next() % 3);
      }

      for (int j = 0; j < 20; j++) {
        int index1 = rng.Next() % spaces.Count;
        int index2 = rng.Next() % spaces.Count;
        if (spaces[index1] != 0) {
          int diff = rng.Next() % spaces[index1];
          spaces[index1] -= diff;
          spaces[index2] += diff;
        }
      }

      foreach (var cand in GetCands(total, spaces)) {
        Debug.Assert(cand.Count == spaces.Count);
        Debug.Assert(cand.Sum() == total);
        for (int v = 0; v < cand.Count; v++) {
          Debug.Assert(cand[v] <= spaces[v]);
        }
        PrintList(cand);
      }
    }
  }

  public void Solve2() {
    int answer = 0;
    for (int index = 0; index < Machines.Count; index++) {
      int cand = GetJoltageButtonPresses(Machines[index]);
      Console.WriteLine($"{index}: {cand}");
      answer += cand;
    }
    Console.WriteLine(answer);
  }


  static int SolveMachine(Machine m) {
    return SolveMachineWithOrTools(m);
  }

  public void Run() {
    _ReadInput();
    // Solve2();

    long answer = 0;
    for (int i = 0; i < Machines.Count; i++) {
      var machine = Machines[i];
      Console.WriteLine($"Solving machine {i}");
      int ans1 = GetJoltageButtonPresses(machine);
      int ans2 = SolveMachine(machine);
      if (ans1 != ans2) {
        Console.WriteLine($"Mismatch on machine {i}: ans1={ans1}, ans2={ans2}");
      }
      answer += ans2;
    }
    Console.WriteLine(answer);

    // Day10Part2.SolvePart2(AllLines.ToArray());
  }
}